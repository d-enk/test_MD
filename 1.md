### AST-оптимизация общих подвыражений
#### Постановка задачи
Реализовать оптимизацию по AST дереву вида:

| До оптимизации | Общие подвыражения | Результат оптимизации |
|-|-|-|
| a = b + c  <br>b = a – d <br>c = b + c  <br>d = a - d   | a = <span style="color:blue">b + c</span><br><span style="color:red">b =</span> <span style="color:green">a – d</span><br>c = <span style="color:blue">b + c</span><br>d = <span style="color:green">a – d</span> | a = b + c  <br><span style="color:green">b</span> = a – d  <br>c = b + c  <br>d = <span style="color:green">b</span> |

#### Команда
Д. Лутченко, М. Письменский

#### Зависимые и предшествующие задачи
Предшествующие задачи:
* AST дерево

#### Теоретическая часть
a = <span style="color:blue">b + c</span>   
<span style="color:red">b =</span> a – d  
c = <span style="color:blue">b + c</span>  
d = a - d  

1. Было ли использовано в правой части
b + c раньше в этом блоке?
2. Если да, то <span style="color:red">в промежутке между этими
определениями менялось ли b или c?</span>  
<span style="color:blue">Да</span>   => не подлежит оптимизации

a = b + c  
b = <span style="color:green">a - d</span>  
c = b + c  
d = <span style="color:green">a - d</span>

1. Было ли использовано в правой части
a - d раньше в этом блоке?
2. Если да, то <span style="color:red">в промежутке между этими
определениями менялось ли a или d?</span>  
<span style="color:green">Нет</span>  => можно оптимизировать

a = b + c  
<span style="color:green">b</span> = a – d  
c = b + c  
d = <span style="color:green">b</span>

#### Практическая часть
###### Примеры реализации метода:


Метод поддерживает проверку коммутативности, что позволяет выполнять оптимизации вида
```csharp
public static bool IsCommutative(Instruction instr)
{
    switch (instr.Operation)
    {
        case "OR":
        case "AND":
        case "EQUAL":
        case "NOTEQUAL":
        case "PLUS":
        case "MULT":
            return true;
    }
    return false;
}
```
Что позволяетв выполять оптимизации вида:  
| До оптимизации | Общие подвыражения | Результат оптимизации |
|-|-|-|
| a = b + c  <br>c = c + b   | a = <span style="color:green">b + c</span><br>c = <span style="color:green">c + b</span> | <span style="color:green">a</span> = b + c<br>c = <span style="color:green">a</span> |

Ориентированнй граф связей подвыражений представлен следующим образом:
```csharp
var exprToResults = new StringToStrings();
var argToExprs = new StringToStrings();
var resultToExpr = new Dictionary<string, string>();
```
Где:  
- `exprToResults` связи выражений к результатам (один ко многим)
- `argToExprs` связи операнд к выражениям (один ко многим)
- `resultToExpr` связь результата с выражением (один к одному)

Для построения общего ключа для выражений с коммутативной операцией применяется сортировка операнд:
```
string uniqueExpr(Instruction instr) =>
	string.Format(IsCommutative(instr) && string.Compare(instr.Argument1, instr.Argument2) > 0 ?
		"{2}{1}{0}" : "{0}{1}{2}", instr.Argument1, instr.Operation, instr.Argument2);
```
Основной алгоритм представляет из себя цикл по входным инструкциям,  
на каждой итерации которого, происходят следующие действия для каждой инструкции:
- создание ключа по выражению
- если для выражения есть связь с результатом
	- то - выполняем оптимизацию
	- иначе - добавляем связи операнд к выражению
- обновлям связи результата и выражения
- если результат имеет связь с выражениями как операнд - удаляем все зависимые связи
```csharp
for (var i = 0; i < instructions.Count; ++i)
{
    var expr = uniqueExpr(instructions[i]);
    if (instructions[i].Operation != "assign" &&
    	exprToResults.TryGetValue(expr, out var results) &&
	results.Count != 0)
    {
        changed = true;
        newInstructions.Add(new Instruction(instructions[i].Label, 
						"assign", 
						results.First(), "", 
						instructions[i].Result));
    }
    else
    {
        newInstructions.Add(instructions[i].Copy());
        addLink(argToExprs, instructions[i].Argument1, expr);
        addLink(argToExprs, instructions[i].Argument2, expr);
    }

    if (resultToExpr.TryGetValue(instructions[i].Result, out var oldExpr))
    {
        if (exprToResults.ContainsKey(oldExpr))
        {
            exprToResults[oldExpr].Remove(instructions[i].Result);
        }
    }

    resultToExpr[instructions[i].Result] = expr;
    addLink(exprToResults, expr, instructions[i].Result);

    if (argToExprs.ContainsKey(instructions[i].Result))
    {
        foreach (var delExpr in argToExprs[instructions[i].Result])
        {
            if (exprToResults.ContainsKey(delExpr))
            {
                foreach (var res in exprToResults[delExpr])
                {
                    resultToExpr.Remove(res);
                }
            }
            exprToResults.Remove(delExpr);
        }
    }
}
```
###### Без унарных операций:
```csharp
[Test]
public void NotUnarOp()
{
    var TAC = GenTAC(@"
var a, b, c, k;
a = b;
k = b;
");

    var (ok, instructions) = ThreeAddressCodeCommonExprElimination.CommonExprElimination(TAC);
    Assert.IsFalse(ok);
    var expected = new List<string>()
    {
        "a = b",
        "k = b"
    };
    var actual = instructions.Select(instruction => instruction.ToString());

    CollectionAssert.AreEqual(expected, actual);
}
```  
###### Константы:
```csharp
[Test]
public void Constants()
{
    var TAC = GenTAC(@"
var a, b, c, k;
a = 5;
k = 5;
");

    var (ok, instructions) = ThreeAddressCodeCommonExprElimination.CommonExprElimination(TAC);
    Assert.IsFalse(ok);
    var expected = new List<string>()
    {
        "a = 5",
        "k = 5"
    };
    var actual = instructions.Select(instruction => instruction.ToString());

    CollectionAssert.AreEqual(expected, actual);
}

```

